# EXAMPLE FILE: How other repositories would call APIM templates
# Copy this to your repo and customize the template paths and parameters

name: APIM Full Deployment - Complete API Lifecycle

on:
  # Customize triggers based on your repo structure
  push:
    branches:
      - main
      - develop
    paths:
      - 'apis/**/*.json'
      - 'apis/**/*.yml'
      - 'policies/**/*.xml'
      - 'configuration.extractor.*.yml'
  
  workflow_dispatch:
    inputs:
      PROJECT_NAME:
        description: "Project name (used for configuration files)"
        required: true
        type: string
      API_NAME:
        description: "API Name in APIM"
        required: true
        type: string
      OPENAPI_FILE_PATH:
        description: "Path to OpenAPI specification file"
        required: true
        type: string
      POLICY_FILE_PATH:
        description: "Path to policy XML file (relative to repo root)"
        required: false
        type: string
      PRODUCT_NAME:
        description: "Product name to link the API to"
        required: false
        type: string
      API_SPECIFICATION_FORMAT:
        description: "API Specification Format for extraction"
        required: true
        type: choice
        default: "OpenAPIV3Yml"
        options:
          - OpenAPIV3Yml
          - OpenAPIV3Json
          - OpenAPIV2Yml
          - OpenAPIV2Json

env:
  API_MANAGEMENT_SERVICE_OUTPUT_FOLDER_PATH: apimartifacts

jobs:
  # Step 1: Push API to APIM
  # Replace 'norconsult-digital/.github' with your organization's .github repo path
  push-openapi:
    name: Push OpenAPI to APIM
    uses: norconsult-digital/.github/.github/workflows/apim-push-openapi.yml@main
    with:
      API_NAME: ${{ inputs.API_NAME }}
      OPENAPI_FILE_PATH: ${{ inputs.OPENAPI_FILE_PATH }}
    secrets: inherit

  # Step 2: Link project-specific policies (optional - remove if not needed)
  link-policies:
    name: Link API Policies
    needs: push-openapi
    if: ${{ inputs.POLICY_FILE_PATH != '' }}
    uses: norconsult-digital/.github/.github/workflows/apim-link-policy.yml@main
    with:
      API_NAME: ${{ inputs.API_NAME }}
      POLICY_FILE_PATH: ${{ inputs.POLICY_FILE_PATH }}
    secrets: inherit

  # Step 3: Link project-specific products (optional - remove if not needed)
  link-products:
    name: Link API to Products
    needs: [push-openapi, link-policies]
    if: ${{ always() && inputs.PRODUCT_NAME != '' && needs.push-openapi.result == 'success' }}
    uses: norconsult-digital/.github/.github/workflows/apim-link-product.yml@main
    with:
      API_NAME: ${{ inputs.API_NAME }}
      PRODUCT_NAME: ${{ inputs.PRODUCT_NAME }}
    secrets: inherit

  # Step 4: Extract code to repo with project-specific configuration (optional)
  extract-to-repo:
    name: Extract APIM Configuration
    needs: [push-openapi, link-policies, link-products]
    if: always() && needs.push-openapi.result == 'success'
    uses: norconsult-digital/.github/.github/workflows/apim-run-extractor.yml@main
    with:
      CONFIGURATION_YML_PATH: configuration.extractor.${{ inputs.PROJECT_NAME }}.yml
      API_SPECIFICATION_FORMAT: ${{ inputs.API_SPECIFICATION_FORMAT }}
      PROJECT_NAME: ${{ inputs.PROJECT_NAME }}
    secrets: inherit

  # Step 5: Create PR with extracted configuration
  # Publishing to non-prod happens automatically when this PR is approved and merged
  # The apim-run-publisher.yml workflow will trigger on merge to deploy artifacts
  create-pull-request:
    name: Create PR with Extracted Config
    needs: extract-to-repo
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v6

      - name: Download extracted artifacts
        uses: actions/download-artifact@v7
        with:
          name: apim-artifacts-${{ inputs.PROJECT_NAME }}
          path: ${{ github.workspace }}/${{ env.API_MANAGEMENT_SERVICE_OUTPUT_FOLDER_PATH }}

      - name: Create pull request
        uses: peter-evans/create-pull-request@v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "feat: deploy ${{ inputs.API_NAME }} to non-prod"
          title: "[${{ inputs.PROJECT_NAME }}] Deploy ${{ inputs.API_NAME }}"
          body: |
            ## API Deployment Summary
            
            **Project:** ${{ inputs.PROJECT_NAME }}
            **API Name:** ${{ inputs.API_NAME }}
            **OpenAPI Spec:** ${{ inputs.OPENAPI_FILE_PATH }}
            **Policy Applied:** ${{ inputs.POLICY_FILE_PATH || 'None' }}
            **Product Linked:** ${{ inputs.PRODUCT_NAME || 'None' }}
            
            ### What's Changed
            - ✅ API definition created in APIM
            - ✅ Policies configured
            - ✅ Products linked
            - ✅ Configuration extracted to `apimartifacts/` folder
            
            ### Deployment Flow
            1. **Review this PR** - Check the extracted APIM configuration
            2. **Approve and merge** - This commits the artifacts to the repo
            3. **Auto-deploy to non-prod** - The `apim-run-publisher` workflow triggers on merge
            4. **Validate in non-prod** - Test the API in the non-prod environment
            5. **Production deployment** - After validation, the publisher workflow will deploy to prod
            
            > ⚠️ **Note**: Actual deployment to APIM environments happens when this PR is merged, not when it's created.
            
            ---
            *This PR was auto-generated by the APIM Full Deployment workflow*
          labels: |
            apim-deployment
            ${{ inputs.PROJECT_NAME }}
            awaiting-review
          branch: apim-deploy-${{ inputs.PROJECT_NAME }}-${{ github.run_number }}
